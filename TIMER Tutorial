#include "stm32f1xx.h"
void Clock_Init(void)
{
    /* ============================================================
     * (1) Flash wait state setting
     *  - 72MHz @ 2.0~3.6V → 2 wait states
     * ============================================================ */
    FLASH->ACR &= ~(0x7);		   // LATENCY realted bits clear
    FLASH->ACR |=  (0x2);          // LATENCY = 2WS, resolve Speed Difference BTWN FLASH Memory and CPU
    FLASH->ACR |=  (1 << 4);       // Prefetch enable, bring next CMD in advance


    /* ============================================================
     * (2) Enable HSI and use it as SYSCLK (safe clock)
     * ============================================================ */
    RCC->CR |= (1 << 0);           // HSION
    while (!(RCC->CR & (1 << 1))); // HSIRDY bit is 1 --> HSI is working now! --> "FALSE"

    RCC->CFGR &= ~(0x3 << 0);      // SW = HSI
    while (((RCC->CFGR >> 2) & 0x3) != 0x0); // SWS = HSI, when SWS bits are 0b00 --> HSI is selected for SYSCLK --> FALSE"


    /* ============================================================
     * (3) Enable HSE
     * ============================================================ */
    RCC->CR |= (1 << 16);          // HSEON
    while (!(RCC->CR & (1 << 17))); // HSERDY,  when HSERDY bit is 1 --> HSE is working now! --> "FALSE"


    /* ============================================================
     * (4) Disable PLL before configuration
     * ============================================================ */
    RCC->CR &= ~(1 << 24);         // PLLON = 0
    while (RCC->CR & (1 << 25));   // wait until PLLRDY = 0 --> PLL is ready to be modified --> "FALSE"


    /* ============================================================
     * (5) PLL configuration
     *  HSE = 8MHz
     *  PLLSRC = HSE
     *  PLLMUL = x9 → 72MHz
     * ============================================================ */
    RCC->CFGR &= ~((0xF << 18) | (1 << 16)); //PLL related initialization (PLLMUL, PLLSRC)
    RCC->CFGR |=  ((7 << 18) | (1 << 16)); // PLLMUL x9, PLLSRC = HSE


    /* ============================================================
     * (6) AHB / APB Prescaler
     * ============================================================ */
    RCC->CFGR &= ~(0xF << 4);      // AHB = SYSCLK /1

    RCC->CFGR &= ~(0x7 << 8);
    RCC->CFGR |=  (0x4 << 8);      // APB1 = AHB /2 (36MHz)

    RCC->CFGR &= ~(0x7 << 11);
    RCC->CFGR |=  (0x4 << 11);     // APB2 = AHB /2 (36MHz)


    /* ============================================================
     * (7) Enable PLL
     * ============================================================ */
    RCC->CR |= (1 << 24);          // PLLON
    while (!(RCC->CR & (1 << 25))); // PLLRDY bit is 1 --> PLL is working now! --> "FALSE"


    /* ============================================================
     * (8) SYSCLK = PLL
     * ============================================================ */
    RCC->CFGR &= ~(0x3 << 0);  // clear up SW bits
    RCC->CFGR |=  (0x2 << 0);      // SW = PLL, select PLL as SYSCLK

    while (((RCC->CFGR >> 2) & 0x3) != 0x2); // SWS = PLL, when SWS bits are 0b10 --> PLL is selected for SYSCLK --> "FALSE"


}


void TIM1_UP_TIM10_IRQHandler(void){

	if(TIM1->SR & 0x0001)// UIF: Update interrupt pending.
		//This bit is set by hardware when the registers are updated
	{
		TIM1->SR &= ~0x0001; // clear UIF
		GPIOC->ODR ^= 0x00002000; //LED Toggle
	}


}

int main(void){

	Clock_Init(); // TIMxCLK --> 36MHz(PCLK2) x 2 = 72MHz

	//Clock configuration
	RCC->APB2ENR |= 0x00000010; //IO port C clock enable


	//LED Port configuration
	GPIOC->CRH &= ~(0x00F00000);
	GPIOC->CRH |= 0x00100000;//output mode & Maximum output speed 10 MHz

	//Timer Configuration
	RCC->APB2ENR |= 0x00000800;// TIM1EN: TIM1 timer clock enable
	TIM1->PSC = (7200-1); // 72MHz / (7200-1) = 10kHz (1cnt / 0.0001 sec)
	TIM1->ARR = (5000-1); // 5000cnt(MAX) ==> 0.5 sec (LED Toggle!),10000cnt(MAX) ==> 1 sec (LED Toggle!)
	TIM1->EGR = 0x0001; //apply the PSC, ARR settings immediately (UG =  1)

	TIM1->DIER |= 0x0001; //Bit 0 UIE: Update interrupt enable
	NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);// TIM1 Update interrupt

	TIM1->CR1 |= 0x0001; //Bit 0 CEN: Counter enable, Bit 4 DIR: upcounter

	while(1){

	}

}
